/**
 * Audit Service
 * Manages audit logging and compliance reporting
 */

const config = require('../config/config');

class AuditService {
  constructor() {
    this.auditLogs = new Map(); // In-memory store (replace with MongoDB in production)
    this.logIndex = new Map(); // Index for quick lookups
  }

  /**
   * Log generic audit event
   */
  async logAuditEvent(event) {
    try {
      const { auditId, userId, payload } = event;
      const { action, resource, resourceId, changes, ipAddress, userAgent, result } = payload;

      const auditLog = {
        auditId: auditId || `audit-${Date.now()}`,
        userId,
        action,
        resource,
        resourceId,
        changes,
        ipAddress,
        userAgent,
        result,
        timestamp: event.timestamp || new Date(),
        eventType: 'audit.log'
      };

      this.auditLogs.set(auditLog.auditId, auditLog);
      this.indexLog(auditLog);

      console.log(`✓ Audit log created: ${auditLog.auditId} - ${action} on ${resource}`);

      return auditLog;
    } catch (error) {
      console.error('Error logging audit event:', error);
      throw error;
    }
  }

  /**
   * Log authentication event
   */
  async logAuthEvent(event) {
    try {
      const { auditId, userId, payload } = event;
      const { action, ipAddress, userAgent, success, failureReason } = payload;

      const auditLog = {
        auditId: auditId || `auth-${Date.now()}`,
        userId,
        action,
        ipAddress,
        userAgent,
        success,
        failureReason,
        timestamp: event.timestamp || new Date(),
        eventType: 'audit.auth',
        severity: success ? 'info' : 'warning'
      };

      this.auditLogs.set(auditLog.auditId, auditLog);
      this.indexLog(auditLog);

      console.log(`✓ Auth audit: ${action} - ${success ? 'SUCCESS' : 'FAILED'} (User: ${userId})`);

      return auditLog;
    } catch (error) {
      console.error('Error logging auth event:', error);
      throw error;
    }
  }

  /**
   * Log data access event
   */
  async logDataAccessEvent(event) {
    try {
      const { auditId, userId, payload } = event;
      const { action, dataType, dataId, sensitivityLevel, reason } = payload;

      const auditLog = {
        auditId: auditId || `data-${Date.now()}`,
        userId,
        action,
        dataType,
        dataId,
        sensitivityLevel,
        reason,
        timestamp: event.timestamp || new Date(),
        eventType: 'audit.data',
        severity: this.getSeverityForDataAccess(action, sensitivityLevel)
      };

      this.auditLogs.set(auditLog.auditId, auditLog);
      this.indexLog(auditLog);

      console.log(`✓ Data access audit: ${action} ${dataType} (${sensitivityLevel})`);

      return auditLog;
    } catch (error) {
      console.error('Error logging data access event:', error);
      throw error;
    }
  }

  /**
   * Auto-audit for critical operations
   */
  async autoAudit(action, event) {
    try {
      const auditLog = {
        auditId: `auto-${action}-${Date.now()}`,
        userId: event.userId,
        action,
        resource: this.getResourceType(action),
        resourceId: event.surveyId || event.responseId || event.id,
        timestamp: event.timestamp || new Date(),
        eventType: 'audit.auto',
        eventData: event,
        autoGenerated: true
      };

      this.auditLogs.set(auditLog.auditId, auditLog);
      this.indexLog(auditLog);

      console.log(`✓ Auto-audit: ${action} (Resource: ${auditLog.resourceId})`);

      return auditLog;
    } catch (error) {
      console.error('Error creating auto-audit:', error);
      throw error;
    }
  }

  /**
   * Index log for quick lookups
   */
  indexLog(log) {
    // Index by userId
    if (log.userId) {
      if (!this.logIndex.has(`user:${log.userId}`)) {
        this.logIndex.set(`user:${log.userId}`, []);
      }
      this.logIndex.get(`user:${log.userId}`).push(log.auditId);
    }

    // Index by action
    if (log.action) {
      if (!this.logIndex.has(`action:${log.action}`)) {
        this.logIndex.set(`action:${log.action}`, []);
      }
      this.logIndex.get(`action:${log.action}`).push(log.auditId);
    }

    // Index by resource
    if (log.resource) {
      if (!this.logIndex.has(`resource:${log.resource}`)) {
        this.logIndex.set(`resource:${log.resource}`, []);
      }
      this.logIndex.get(`resource:${log.resource}`).push(log.auditId);
    }
  }

  /**
   * Query audit logs
   */
  async queryLogs(filters) {
    try {
      const { userId, action, resource, startDate, endDate, limit = 100 } = filters;

      let logs = Array.from(this.auditLogs.values());

      // Apply filters
      if (userId) {
        const userLogIds = this.logIndex.get(`user:${userId}`) || [];
        logs = logs.filter(log => userLogIds.includes(log.auditId));
      }

      if (action) {
        const actionLogIds = this.logIndex.get(`action:${action}`) || [];
        logs = logs.filter(log => actionLogIds.includes(log.auditId));
      }

      if (resource) {
        const resourceLogIds = this.logIndex.get(`resource:${resource}`) || [];
        logs = logs.filter(log => resourceLogIds.includes(log.auditId));
      }

      if (startDate) {
        const start = new Date(startDate);
        logs = logs.filter(log => new Date(log.timestamp) >= start);
      }

      if (endDate) {
        const end = new Date(endDate);
        logs = logs.filter(log => new Date(log.timestamp) <= end);
      }

      // Sort by timestamp descending
      logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

      // Apply limit
      return logs.slice(0, limit);
    } catch (error) {
      console.error('Error querying audit logs:', error);
      throw error;
    }
  }

  /**
   * Get single audit log
   */
  async getLog(auditId) {
    return this.auditLogs.get(auditId);
  }

  /**
   * Generate compliance report
   */
  async generateComplianceReport(startDate, endDate) {
    try {
      const logs = await this.queryLogs({ startDate, endDate, limit: 10000 });

      const report = {
        period: {
          start: startDate,
          end: endDate
        },
        totalEvents: logs.length,
        eventsByType: {},
        eventsByUser: {},
        authenticationEvents: {
          total: 0,
          successful: 0,
          failed: 0
        },
        dataAccessEvents: {
          total: 0,
          bySensitivity: {}
        },
        criticalEvents: [],
        complianceStandards: config.audit.complianceStandards,
        generatedAt: new Date()
      };

      // Analyze logs
      logs.forEach(log => {
        // Count by event type
        report.eventsByType[log.eventType] = (report.eventsByType[log.eventType] || 0) + 1;

        // Count by user
        if (log.userId) {
          report.eventsByUser[log.userId] = (report.eventsByUser[log.userId] || 0) + 1;
        }

        // Authentication events
        if (log.eventType === 'audit.auth') {
          report.authenticationEvents.total++;
          if (log.success) {
            report.authenticationEvents.successful++;
          } else {
            report.authenticationEvents.failed++;
          }
        }

        // Data access events
        if (log.eventType === 'audit.data') {
          report.dataAccessEvents.total++;
          const sensitivity = log.sensitivityLevel || 'unknown';
          report.dataAccessEvents.bySensitivity[sensitivity] =
            (report.dataAccessEvents.bySensitivity[sensitivity] || 0) + 1;
        }

        // Critical events
        if (log.severity === 'critical' || log.severity === 'warning') {
          report.criticalEvents.push({
            auditId: log.auditId,
            timestamp: log.timestamp,
            action: log.action,
            severity: log.severity
          });
        }
      });

      console.log(`✓ Generated compliance report: ${report.totalEvents} events`);

      return report;
    } catch (error) {
      console.error('Error generating compliance report:', error);
      throw error;
    }
  }

  /**
   * Get severity level for data access
   */
  getSeverityForDataAccess(action, sensitivityLevel) {
    if (action === 'delete' && ['confidential', 'restricted'].includes(sensitivityLevel)) {
      return 'critical';
    }
    if (action === 'export' && sensitivityLevel === 'restricted') {
      return 'warning';
    }
    return 'info';
  }

  /**
   * Get resource type from action
   */
  getResourceType(action) {
    if (action.includes('survey')) return 'survey';
    if (action.includes('response')) return 'response';
    if (action.includes('surveyor')) return 'surveyor';
    return 'unknown';
  }

  /**
   * Get audit statistics
   */
  async getStatistics() {
    return {
      totalLogs: this.auditLogs.size,
      indexedUsers: Array.from(this.logIndex.keys()).filter(k => k.startsWith('user:')).length,
      indexedActions: Array.from(this.logIndex.keys()).filter(k => k.startsWith('action:')).length,
      indexedResources: Array.from(this.logIndex.keys()).filter(k => k.startsWith('resource:')).length
    };
  }
}

module.exports = new AuditService();

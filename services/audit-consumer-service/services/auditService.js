/**
 * Enhanced Audit Service with MongoDB Storage
 * Manages audit logging and compliance reporting
 */

const AuditLog = require('../models/AuditLog');
const config = require('../config/config');

class AuditService {
  constructor() {
    console.log('Initializing Enhanced Audit Service with MongoDB storage');
  }

  /**
   * Log generic audit event
   */
  async logAuditEvent(event) {
    try {
      const { eventId, userId, payload, timestamp } = event;
      const { action, resource, resourceId, changes, ipAddress, userAgent, result } = payload || {};

      const auditData = {
        eventId: eventId || `audit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        eventType: event.eventType || 'audit.log',
        category: 'audit',
        action: action || 'unknown',
        userId,
        resource: resource ? { type: resource, id: resourceId } : undefined,
        changes,
        metadata: { ipAddress, userAgent },
        result: result || 'success',
        timestamp: timestamp || new Date()
      };

      const auditLog = await AuditLog.logEvent(auditData);

      console.log(`✓ Audit log created: ${auditLog.eventId} - ${action} on ${resource}`);

      return auditLog;
    } catch (error) {
      console.error('Error logging audit event:', error);
      throw error;
    }
  }

  /**
   * Log authentication event
   */
  async logAuthEvent(event) {
    try {
      const { eventId, userId, payload, timestamp } = event;
      const { action, ipAddress, userAgent, success, failureReason } = payload || {};

      const auditData = {
        eventId: eventId || `auth-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        eventType: 'auth.' + (action || 'unknown'),
        category: 'auth',
        action: action || 'unknown',
        userId,
        metadata: { ipAddress, userAgent, failureReason },
        result: success ? 'success' : 'failure',
        errorMessage: success ? undefined : failureReason,
        timestamp: timestamp || new Date()
      };

      const auditLog = await AuditLog.logEvent(auditData);

      console.log(`✓ Auth audit: ${action} - ${success ? 'SUCCESS' : 'FAILED'} (User: ${userId})`);

      return auditLog;
    } catch (error) {
      console.error('Error logging auth event:', error);
      throw error;
    }
  }

  /**
   * Log data access event
   */
  async logDataAccessEvent(event) {
    try {
      const { eventId, userId, payload, timestamp } = event;
      const { action, dataType, dataId, sensitivityLevel, reason } = payload || {};

      const auditData = {
        eventId: eventId || `data-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        eventType: 'data.' + (action || 'access'),
        category: 'data',
        action: action || 'access',
        userId,
        resource: { type: dataType, id: dataId },
        metadata: { sensitivityLevel, reason },
        result: 'success',
        timestamp: timestamp || new Date()
      };

      const auditLog = await AuditLog.logEvent(auditData);

      console.log(`✓ Data access audit: ${action} ${dataType} (${sensitivityLevel})`);

      return auditLog;
    } catch (error) {
      console.error('Error logging data access event:', error);
      throw error;
    }
  }

  /**
   * Auto-audit for critical operations
   */
  async autoAudit(action, event) {
    try {
      const resourceType = this.getResourceType(action);
      const resourceId = event.surveyId || event.responseId || event.id;

      const auditData = {
        eventId: `auto-${action}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        eventType: event.eventType || action,
        category: resourceType,
        action: action.replace(/^(survey|response|surveyor)_/, ''),
        userId: event.userId,
        resource: { type: resourceType, id: resourceId },
        metadata: { autoGenerated: true, eventData: event },
        result: 'success',
        timestamp: event.timestamp || new Date()
      };

      const auditLog = await AuditLog.logEvent(auditData);

      console.log(`✓ Auto-audit: ${action} (Resource: ${resourceId})`);

      return auditLog;
    } catch (error) {
      console.error('Error creating auto-audit:', error);
      throw error;
    }
  }

  /**
   * Query audit logs (delegates to AuditLog model)
   */
  async queryLogs(filters) {
    try {
      const result = await AuditLog.search(filters);
      return result.logs;
    } catch (error) {
      console.error('Error querying audit logs:', error);
      throw error;
    }
  }

  /**
   * Get single audit log
   */
  async getLog(auditId) {
    try {
      return await AuditLog.findOne({ eventId: auditId }).lean();
    } catch (error) {
      console.error('Error getting audit log:', error);
      throw error;
    }
  }

  /**
   * Generate compliance report
   */
  async generateComplianceReport(startDate, endDate) {
    try {
      const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const end = endDate ? new Date(endDate) : new Date();

      const logs = await AuditLog.find({
        timestamp: { $gte: start, $lte: end }
      }).lean();

      const report = {
        period: {
          start: start.toISOString(),
          end: end.toISOString()
        },
        totalEvents: logs.length,
        eventsByCategory: {},
        eventsByAction: {},
        eventsByUser: {},
        eventsBySeverity: {},
        authenticationEvents: {
          total: 0,
          successful: 0,
          failed: 0
        },
        dataAccessEvents: {
          total: 0,
          bySensitivity: {}
        },
        criticalEvents: [],
        complianceStandards: config.audit.complianceStandards,
        generatedAt: new Date()
      };

      // Analyze logs
      logs.forEach(log => {
        // Count by category
        report.eventsByCategory[log.category] = (report.eventsByCategory[log.category] || 0) + 1;

        // Count by action
        report.eventsByAction[log.action] = (report.eventsByAction[log.action] || 0) + 1;

        // Count by user
        if (log.userId) {
          report.eventsByUser[log.userId] = (report.eventsByUser[log.userId] || 0) + 1;
        }

        // Count by severity
        report.eventsBySeverity[log.severity] = (report.eventsBySeverity[log.severity] || 0) + 1;

        // Authentication events
        if (log.category === 'auth') {
          report.authenticationEvents.total++;
          if (log.result === 'success') {
            report.authenticationEvents.successful++;
          } else {
            report.authenticationEvents.failed++;
          }
        }

        // Data access events
        if (log.category === 'data') {
          report.dataAccessEvents.total++;
          const sensitivity = log.metadata?.sensitivityLevel || 'unknown';
          report.dataAccessEvents.bySensitivity[sensitivity] =
            (report.dataAccessEvents.bySensitivity[sensitivity] || 0) + 1;
        }

        // Critical events
        if (log.severity === 'critical' || log.severity === 'warning') {
          report.criticalEvents.push({
            eventId: log.eventId,
            timestamp: log.timestamp,
            eventType: log.eventType,
            action: log.action,
            severity: log.severity,
            userId: log.userId
          });
        }
      });

      console.log(`✓ Generated compliance report: ${report.totalEvents} events`);

      return report;
    } catch (error) {
      console.error('Error generating compliance report:', error);
      throw error;
    }
  }

  /**
   * Get resource type from action
   */
  getResourceType(action) {
    if (action.includes('survey')) return 'survey';
    if (action.includes('response')) return 'response';
    if (action.includes('surveyor')) return 'surveyor';
    if (action.includes('user')) return 'user';
    if (action.includes('project')) return 'project';
    return 'unknown';
  }

  /**
   * Get audit statistics
   */
  async getStatistics() {
    try {
      const stats = await AuditLog.getStatistics(7); // Last 7 days

      return {
        totalEvents: stats.totalEvents?.[0]?.count || 0,
        byCategory: stats.byCategory || [],
        bySeverity: stats.bySeverity || [],
        byResult: stats.byResult || [],
        topUsers: stats.topUsers || [],
        recentCritical: stats.recentCritical || []
      };
    } catch (error) {
      console.error('Error getting statistics:', error);
      return {
        totalEvents: 0,
        byCategory: [],
        bySeverity: [],
        byResult: [],
        topUsers: [],
        recentCritical: []
      };
    }
  }

  /**
   * Export audit logs in various formats
   */
  async exportLogs(filters, format = 'json') {
    try {
      const result = await AuditLog.search({ ...filters, limit: 10000 });

      if (format === 'csv') {
        return this.convertToCSV(result.logs);
      }

      return result.logs;
    } catch (error) {
      console.error('Error exporting logs:', error);
      throw error;
    }
  }

  /**
   * Convert logs to CSV format
   */
  convertToCSV(logs) {
    if (logs.length === 0) {
      return 'No data';
    }

    const headers = [
      'Event ID',
      'Timestamp',
      'Event Type',
      'Category',
      'Action',
      'User ID',
      'Resource Type',
      'Resource ID',
      'Result',
      'Severity'
    ];

    const rows = logs.map(log => [
      log.eventId,
      log.timestamp,
      log.eventType,
      log.category,
      log.action,
      log.userId || '',
      log.resource?.type || '',
      log.resource?.id || '',
      log.result,
      log.severity
    ]);

    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');

    return csvContent;
  }
}

module.exports = new AuditService();
